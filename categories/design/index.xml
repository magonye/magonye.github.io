<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Learnings and thoughts</title>
    <link>http://magonye.github.io/categories/design/index.xml</link>
    <description>Recent content in Design on Learnings and thoughts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://magonye.github.io/categories/design/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simple Design</title>
      <link>http://magonye.github.io/post/simple-design/</link>
      <pubDate>Wed, 21 Mar 2018 08:37:49 +0100</pubDate>
      
      <guid>http://magonye.github.io/post/simple-design/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://pixabay.com/en/users/FelixMittermeier-4397258/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; title=&#34;Download free do whatever you want high-resolution photos from FelixMittermeier&#34;&gt;&lt;img src=&#34;https://magonye.github.io/img/simple-design.jpg&#34; /&gt;&lt;/a&gt;
&lt;br&gt;&lt;br&gt;
Several months ago, I wrote about some known design principles: SOLID, YAGNI, DRY, &amp;hellip;.. (you can read the full post &lt;a href=&#34;../../post/design-principles/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;). I was looking to understand and follow these principles for a goal: to write better code. And when I talk about &amp;ldquo;better&amp;rdquo; code, I mean readable and maintainable code. Code that every developer in a company should be able to maintain in a future. No matter if I&amp;rsquo;m still in the company or not.&lt;/p&gt;

&lt;p&gt;I have to admit that some of the principles that I wrote about were tough to understand to me. And they were tougher to apply on my daily basis work. In fact, sometimes, when applying some of the SOLID principles in our code, it can look more unreadable and unmaintainable than before. What the hell!!! What was happening here?&lt;/p&gt;

&lt;p&gt;It could be that design patterns are good, when they apply to a concrete scenario. So, I thought that it was needed some higher-level rules, not so specific, that I might apply, if not always, most of the times. The following post tries to explain some rules I started to follow in order to achieve that better design that we all are looking for.&lt;/p&gt;

&lt;h2 id=&#34;rules-of-simple-design&#34;&gt;Rules of Simple Design&lt;/h2&gt;

&lt;p&gt;Design should be a constant in our work, an improvement process that make us to have a Better Design, instead of a Good Design. There is no formula for that Good Design.&lt;/p&gt;

&lt;p&gt;In order to achieve this improvement, what has sense to me is to think in a Simple Design, easy to change, and that fits in what I think a Better Design should be.&lt;/p&gt;

&lt;p&gt;For that purpose, Kent Beck created the &lt;strong&gt;4 Rules of Simplicity&lt;/strong&gt;, and they became tremendous known when they appeared on &lt;a href=&#34;https://www.goodreads.com/book/show/3735293-clean-code&#34; target=&#34;_blank&#34;&gt;Clean Code&lt;/a&gt; book by &lt;a href=&#34;https://twitter.com/unclebobmartin&#34; target=&#34;_blank&#34;&gt;Robert C. Martin&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Passes all the tests.&lt;/li&gt;
&lt;li&gt;Expresses every idea that we need to express.&lt;/li&gt;
&lt;li&gt;Says everything one and only once.&lt;/li&gt;
&lt;li&gt;Has no superfluous parts.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Looking for brevity, the following rules could work as well:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Tests pass&lt;/li&gt;
&lt;li&gt;Express Intent&lt;/li&gt;
&lt;li&gt;No duplication&lt;/li&gt;
&lt;li&gt;Small&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These are 4 statements or commands, presented as a workflow. These 4 rules combine each other with the following one and they should be iterated until we feel our code is clear and simple enough.&lt;/p&gt;

&lt;h2 id=&#34;values&#34;&gt;Values&lt;/h2&gt;

&lt;p&gt;Sometime after that, Kent Beck wrote a book called &lt;a href=&#34;https://www.goodreads.com/book/show/781559.Implementation_Patterns&#34; target=&#34;_blank&#34;&gt;Implementation Patterns&lt;/a&gt;, and he described the values that were behind his 4 rules. These values are consistent with excellence in programming. I&amp;rsquo;m trying to have them in mind when I write software:&lt;/p&gt;

&lt;h3 id=&#34;communication&#34;&gt;Communication&lt;/h3&gt;

&lt;p&gt;As &lt;a href=&#34;https://www.goodreads.com/quotes/835238-indeed-the-ratio-of-time-spent-reading-versus-writing-is&#34; target=&#34;_blank&#34;&gt;Robert C. Martin said&lt;/a&gt;, we spend more time reading code than writing new one. As a programmer, we should know that we are not only writing code to satisfy a feature. We are also writing code for the programmer that will change that code in the future (maybe ourselves, maybe another programmer).&lt;/p&gt;

&lt;p&gt;For that reason, we need to communicate as much as possible, and we should also break some rules if, breaking that rules, the code communicates better. Who will care in the future if our code is clean code, if nobody understands it?&lt;/p&gt;

&lt;h3 id=&#34;simplicity&#34;&gt;Simplicity&lt;/h3&gt;

&lt;p&gt;In order to understand code, it should be simple. Simple solutions communicate better than complex and smart ones. We need to eliminate complexity of our code. Simplicity should help our code to communicate its purpose. The only reason to keep something more complex should be for the communication.&lt;/p&gt;

&lt;h3 id=&#34;flexibility&#34;&gt;Flexibility&lt;/h3&gt;

&lt;p&gt;Sometimes we write code that tries to satisfy a future feature. We try our software to be flexible to future changes, and sometimes these changes come, but sometimes they never come. That flexibility makes our code complex and hard to maintain.&lt;/p&gt;

&lt;p&gt;Our code should be flexible to allow new changes to come, but not anticipating them. Postponing decisions to the last responsible moment, let you have more information to take into account. Sometimes, when we try to anticipate a feature, we don&amp;rsquo;t have enough information yet. If we postpone the decision until the last possible moment, we have more chance to be successful.&lt;/p&gt;

&lt;h2 id=&#34;learnings&#34;&gt;LEARNINGS&lt;/h2&gt;

&lt;p&gt;I have spent the majority of my professional career as a developer thinking that smart and complex solutions were better. I tried hard to understand code from colleagues that were hard to understand. And I though these developers were awesome and were creating better code than I was.
These times were time of cowboy coders, with no vision of team membership.&lt;/p&gt;

&lt;p&gt;And at some point, in my professional career, I started to work in a team with strong sense of team, a team with a common and clear purpose. And the code didn&amp;rsquo;t belong to me anymore, the code belonged to the team.&lt;/p&gt;

&lt;p&gt;Having these values and applying these rules helps the team with its purpose: to create amazing new features, modify existing ones, but also allowing any member of the team to work on any part of our codebase. There is no magic, and problems on new feature are still there, but I think we are minimizing problems of readability and maintenance. Our solutions are now simpler than before, and for that reason, our codebase is more flexible and allow us to add new behavior with less effort.&lt;/p&gt;

&lt;h2 id=&#34;inspiration&#34;&gt;Inspiration&lt;/h2&gt;

&lt;p&gt;I would like to thank &lt;a href=&#34;https://twitter.com/venkat_s&#34; target=&#34;_blank&#34;&gt;Dr. Venkat Subramaniam&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/fran_reyes&#34; target=&#34;_blank&#34;&gt;Fran Reyes&lt;/a&gt; for the inspiration.&lt;/p&gt;

&lt;p&gt;I was attending the Barcelona Java Conference 2017, and the opening key note was &amp;ldquo;The Art of Simplicity&amp;rdquo;, by &lt;a href=&#34;https://twitter.com/venkat_s&#34; target=&#34;_blank&#34;&gt;Dr. Venkat Subramaniam&lt;/a&gt;. You can see the full video &lt;a href=&#34;https://www.youtube.com/watch?v=Z-8ZGgGadHU&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.
The talk was very inspirational, about the art of making things simple. At the end of the talk, I had the feeling that the search of the simplicity, as itself, was a challenge, and it required a lot to practice, in order to be mastered.&lt;/p&gt;

&lt;p&gt;Later on, at the Community of Practice that we are running at our work, we saw the video &amp;ldquo;Values and Principles in Software Design&amp;rdquo; by @fran_reyes. The talk was originally made at CAS2017, it&amp;rsquo;s in Spanish, and you can see the full video &lt;a href=&#34;https://www.youtube.com/watch?v=sXLCBcELu5Y&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;. This video talks about Kent Beck&amp;rsquo;s values and principles, and examples and advices about how to apply them.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the tweet I made of that session:
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Community of Practice at &lt;a href=&#34;https://twitter.com/Mango?ref_src=twsrc%5Etfw&#34;&gt;@Mango&lt;/a&gt;: Values and Principles in Software Design by &lt;a href=&#34;https://twitter.com/fran_reyes?ref_src=twsrc%5Etfw&#34;&gt;@fran_reyes&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/alwaysLearning?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#alwaysLearning&lt;/a&gt; &lt;a href=&#34;https://t.co/xwC7sj6F8C&#34;&gt;pic.twitter.com/xwC7sj6F8C&lt;/a&gt;&lt;/p&gt;&amp;mdash; Mike Gonzalez (@MikeGonYe) &lt;a href=&#34;https://twitter.com/MikeGonYe/status/961634605576196096?ref_src=twsrc%5Etfw&#34;&gt;February 8, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/p&gt;

&lt;h2 id=&#34;kent-beck&#34;&gt;KENT BECK&lt;/h2&gt;

&lt;p&gt;Everything on that post is about Kent Beck&amp;rsquo;s work. He transformed the software development world. He is the creator of &lt;a href=&#34;http://wiki.c2.com/?ExtremeProgramming&#34; target=&#34;_blank&#34;&gt;extreme programming&lt;/a&gt;, one of the original signatories of the &lt;a href=&#34;http://agilemanifesto.org/&#34; target=&#34;_blank&#34;&gt;Agile Manifesto&lt;/a&gt;, and very related to the &lt;a href=&#34;http://wiki.c2.com/?TestDrivenDevelopment&#34; target=&#34;_blank&#34;&gt;TDD&lt;/a&gt; movement.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t know him, I recommend you start looking for his work.&lt;/p&gt;

&lt;h2 id=&#34;more-info&#34;&gt;More info&lt;/h2&gt;

&lt;p&gt;If you are interested in going further on that topic, here you can find some resources that inspired me, and I recommend you read:&lt;/p&gt;

&lt;p&gt;Books:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.goodreads.com/book/show/781559.Implementation_Patterns&#34; target=&#34;_blank&#34;&gt;Implementation Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.goodreads.com/book/show/21841698-understanding-the-four-rules-of-simple-design&#34; target=&#34;_blank&#34;&gt;Understanding the Four Rules of Simple Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.goodreads.com/book/show/67833.Extreme_Programming_Explained&#34; target=&#34;_blank&#34;&gt;Extreme Programming Explained: Embrace Change&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.goodreads.com/book/show/3735293-clean-code&#34; target=&#34;_blank&#34;&gt;Clean Code: A Handbook of Agile Software Craftsmanship&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.c2.com/?XpSimplicityRules&#34; target=&#34;_blank&#34;&gt;Xp - Simplicity Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://martinfowler.com/bliki/BeckDesignRules.html&#34; target=&#34;_blank&#34;&gt;Beck Design Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.iterate.no/2012/06/20/programming-like-kent-beck/&#34; target=&#34;_blank&#34;&gt;Programming like Kent Beck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Videos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Z-8ZGgGadHU&#34; target=&#34;_blank&#34;&gt;JBCNConf 2017 - Venkat Subramaniam - The Art of Simplicity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=sXLCBcELu5Y&#34; target=&#34;_blank&#34;&gt;CAS2017 - Fran Reyes - Values and Principles in Software Design&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
What do you think about Simple Design? Are you trying to create code that communicates, is simple and flexible?
Any feedback will be very appreciated.&lt;/p&gt;

&lt;p&gt;Photo by &lt;a href=&#34;https://pixabay.com/en/users/FelixMittermeier-4397258/&#34; target=&#34;_blank&#34;&gt;FelixMittermeier&lt;/a&gt; on &lt;a href=&#34;https://pixabay.com/&#34; target=&#34;_blank&#34;&gt;Pixabay&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Principles</title>
      <link>http://magonye.github.io/post/design-principles/</link>
      <pubDate>Fri, 10 Nov 2017 08:48:16 +0100</pubDate>
      
      <guid>http://magonye.github.io/post/design-principles/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://magonye.github.io/img/design-principles.jpg&#34; /&gt;
&lt;a style=&#34;margin:.50em; float: right; background-color:black;color:white;text-decoration:none;padding:4px 6px;font-family:-apple-system, BlinkMacSystemFont, &amp;quot;San Francisco&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Ubuntu, Roboto, Noto, &amp;quot;Segoe UI&amp;quot;, Arial, sans-serif;font-size:12px;font-weight:bold;line-height:1.2;display:inline-block;border-radius:3px;&#34; href=&#34;https://unsplash.com/@yer_a_wizard?utm_medium=referral&amp;amp;utm_campaign=photographer-credit&amp;amp;utm_content=creditBadge&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; title=&#34;Download free do whatever you want high-resolution photos from Fleur Treurniet&#34;&gt;&lt;span style=&#34;display:inline-block;padding:2px 3px;&#34;&gt;&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; style=&#34;height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white;&#34; viewBox=&#34;0 0 32 32&#34;&gt;&lt;title&gt;&lt;/title&gt;&lt;path d=&#34;M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/span&gt;&lt;span style=&#34;display:inline-block;padding:2px 3px;&#34;&gt;Fleur Treurniet&lt;/span&gt;&lt;/a&gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;
I had some concerns about Design Principles, so I talked with my mentor a little about them, their importance and we also tried to demystify them, why not?&lt;/p&gt;

&lt;p&gt;Below there is a recap of the main design principles we covered with this exercise.&lt;/p&gt;

&lt;h1 id=&#34;solid-principles&#34;&gt;SOLID Principles&lt;/h1&gt;

&lt;p&gt;Five design principles intended to make software designs more understandable, flexible and maintainable. They became very popular, as they were promoted by &lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/&#34; target=&#34;_blank&#34;&gt;Robert C. Martin&lt;/a&gt;, and they are now key design principles in object oriented programming.&lt;/p&gt;

&lt;p&gt;I heard some people talking about S.O.L.I.D. as if they were some kind of religion or &lt;em&gt;mantra&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;But are they so important? Let&amp;rsquo;s see each of them, one by one:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Single Responsibility Principle [S.R.P.]:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A class should have one and only one reason to change.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The principle is talking about classes, but you can put here whatever you want: a class, a module, a package, a component, a method &amp;hellip; as you can see, what this principle is talking about is that your software should be low coupled and high cohesive. Object and methods should have only one job. In this way, both the reasons to change a class and the number of classes to change within a feature will be minimized.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Open-Closed Principle [O.C.P.]:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Objects or entities should be open for extension, but closed for modification.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Although it might sound weird at the beginning, this principle is telling that your software should be easy to modify.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to thing about this principle if you think on a &lt;strong&gt;switch sentence&lt;/strong&gt;. Each time you add a new case, you should touch the switch method, putting in risk every case, right?&lt;/p&gt;

&lt;p&gt;I think this principle is hard to accomplish at 100%, but you can minimize the parts you should change when adding new functionality to your software. And this principle should be followed as an advice, so try to make your software easy to extend, but don&amp;rsquo;t get crazy trying so hard!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Liskov Substitution Principle [L.S.P.]:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This principle is a pure Object Oriented thing, it&amp;rsquo;s all about hierarchy. It&amp;rsquo;s telling that you should be careful about inheritance, and don&amp;rsquo;t make mistakes.&lt;/p&gt;

&lt;p&gt;For example, if you have &lt;em&gt;rectangle&lt;/em&gt; objects with &lt;strong&gt;setHeight&lt;/strong&gt; and &lt;strong&gt;setWidth&lt;/strong&gt; methods, &lt;em&gt;square&lt;/em&gt; objects shouldn&amp;rsquo;t extend &lt;em&gt;rectangle&lt;/em&gt;, as their height and width should be the same. &lt;em&gt;Square&lt;/em&gt; objects with separate setters for height and width could bring you some inconsistencies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Interface Segregation Principle [I.S.P.]:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A client should never be forced to implement an interface that it doesn&amp;rsquo;t use or clients shouldn&amp;rsquo;t be forced to depend on methods they don&amp;rsquo;t use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is one of the easiest principles, in my opinion. If a client doesn&amp;rsquo;t need to use a functionality, don&amp;rsquo;t make the client to implement it. It&amp;rsquo;s better to create two clients, and in this way your software can use one client or the other, depending on the functionality needed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependency Inversion Principle [D.I.P.]:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Entities must depend on abstractions not on concretions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This principle encourages you to write code that depends upon abstractions rather than upon concrete details. This is, for me, one of the hardest to understand. What basically is saying is that your program should be based on concepts, not on implementations. In this way, your software will be easy to maintain, and the risks will be minimized.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see an example: if your software needs to use logging features, it&amp;rsquo;s better to use an interface of the logging, instead of use directly the implementation of the logging. If you should make changes on that logging functionality, your code will be safe, as it&amp;rsquo;s based on your interface, not your implementation of that logging.&lt;/p&gt;

&lt;p&gt;For more information about S.O.L.I.D. you can read the &lt;a href=&#34;https://www.goodreads.com/book/show/84985.Agile_Software_Development_Principles_Patterns_and_Practices&#34; target=&#34;_blank&#34;&gt;Agile Software Development, Principles, Patterns, and Practices&lt;/a&gt; book and the following &lt;a href=&#34;http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;, both from &lt;a href=&#34;https://sites.google.com/site/unclebobconsultingllc/&#34; target=&#34;_blank&#34;&gt;Robert C. Martin&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;other-design-principles&#34;&gt;Other Design Principles&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t Repeat Yourself [D.R.Y.]:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The DRY principle states that duplication of logic should be avoided.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.c2.com/?DontRepeatYourself&#34; target=&#34;_blank&#34;&gt;Here&lt;/a&gt; you can read more about this design principle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keep It Simple, Stupid! [K.I.S.S.]:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;KISS principle (&lt;em&gt;Keep It Simple and Small&lt;/em&gt; could be a more polite version) is talking about designing software as much simple as possible. This principle is against the over-engineering solutions that are trying to predict the future, and making them difficult to understand for new developers.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.c2.com/?KeepItSimple&#34; target=&#34;_blank&#34;&gt;Here&lt;/a&gt; you can read more about this design principle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You Aren&amp;rsquo;t Gonna Need It [Y.A.G.N.I]:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This principle states that functionality should not be added to a software program until it&amp;rsquo;s strictly necessary.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.c2.com/?YouArentGonnaNeedIt&#34; target=&#34;_blank&#34;&gt;Here&lt;/a&gt; you can read more about this design principle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Separation of Concerns [SoC]:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Very related to the SRP, SoC is about designing you application having in mind that different concerns should be placed in different parts of your software.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.c2.com/?SeparationOfConcerns&#34; target=&#34;_blank&#34;&gt;Here&lt;/a&gt; you can read more about this design principle.&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Design principles are very important. As much design principles you know, the more qualified you are to do your job, as they are rules, advices and guides about software design.&lt;/p&gt;

&lt;p&gt;Although they are important, you should not be an obsessed of them. Principles are there to help you decide the best option when you are designing. You should know them, slowly, understanding deeply their meaning and purpose. And you should use them wisely, but also with common sense, because there is a thing more important than software design principles. And this thing is the way you code and they way you apply the principles: your craft.&lt;/p&gt;

&lt;p&gt;By following design principles, you will able to make software that is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;maintainable&lt;/li&gt;
&lt;li&gt;usable&lt;/li&gt;
&lt;li&gt;less coupled&lt;/li&gt;
&lt;li&gt;more cohesive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
What do you think about design principles? Are you following them? And what about SOLID principles?
Any feedback will be very appreciated.&lt;/p&gt;

&lt;p&gt;Photo by &lt;a href=&#34;https://unsplash.com/photos/dQf7RZhMOJU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&#34; target=&#34;_blank&#34;&gt;Fleur Treurniet&lt;/a&gt; on &lt;a href=&#34;https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&#34; target=&#34;_blank&#34;&gt;Unsplash&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>